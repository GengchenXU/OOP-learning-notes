在公有派生的情况下，有以下三条赋值兼容规则。

*   派生类的对象可以赋值给基类对象。
*   派生类对象可以用来初始化基类引用。
*   派生类对象的地址可以赋值给基类[指针](http://c.biancheng.net/c/80/)，亦即派生类的指针可以赋值给基类的指针。

上面三条反过来是不成立的。例如，不能把基类对象赋值给派生类对象。

下面的程序能够成功编译，充分说明了上述三条规则。

```cpp
class A {
};
class B : public A  //公有派生
{
};
int main()
{
    A a;
    B b;
    a = b;  //派生类对象赋值给基类对象
    A& r = b;  //派生类对象初始化基类引用
    A* pa = &b;  //派生类对象地址赋值给基类指针
    B* pb = &b;
    pa = pb;  //派生类指针赋值给基类指针
    return 0;
}
```

将派生类对象赋值给基类对象（如上面程序中的`a=b;`语句），在赋值号没有被重载的情况下，所做的操作就是将派生类对象中的基类对象逐个字节地复制到`=`左边的基类对象中。

在公有派生的情况下，可以说，派生类对象也是基类对象，任何本该出现基类对象的地方，如果出现的是派生类的对象，也是没有问题的。但如果派生方式不是 public，而是 private 或 protected，那么上面这个结论就不成立了。